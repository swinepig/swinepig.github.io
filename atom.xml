<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Swinepig</title>
  <subtitle>情流感的博格</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://swinepig.github.io/"/>
  <updated>2016-09-03T12:39:22.402Z</updated>
  <id>https://swinepig.github.io/</id>
  
  <author>
    <name>xin zhu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记一次数据迁移的经历</title>
    <link href="https://swinepig.github.io/2016/08/28/db2datatransfer/"/>
    <id>https://swinepig.github.io/2016/08/28/db2datatransfer/</id>
    <published>2016-08-28T08:08:34.000Z</published>
    <updated>2016-09-03T12:39:22.402Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间公司要求我们项目版本做一次回收，因需要回公司做演示还需要将服务器数据考回到本地–这步比较棘手因为客户方开发环境U盘无法使用=。=，最后好不容易找了个借口<br>向别人搞了个内部U盘。</p>
<p>我们开发环境为AIX+DB2，因为只需做演示使用数据导出觉定不采用 <code>db2move</code> 命令，只选取全部基础表+少量业务表做数据导出(使用 <code>export</code> 命令)</p>
<p>总的来说按照以下步骤进行：</p>
<ul>
<li>源数据源数据导出(export)</li>
<li>源数据库表结构等导出(db2look)</li>
<li>本地Win环境安装DB2，重建数据库(缓冲区，表空间，索引空间等)</li>
<li>本地数据结构恢复(db2 -tf db2look.sql)</li>
<li>本地数据恢复(import)</li>
</ul>
<h2 id="具体详细步骤"><a href="#具体详细步骤" class="headerlink" title="具体详细步骤"></a>具体详细步骤</h2><h3 id="源数据源数据导出"><a href="#源数据源数据导出" class="headerlink" title="源数据源数据导出"></a>源数据源数据导出</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">db2 connect <span class="keyword">to</span> dbname</div><div class="line">db2 -<span class="keyword">tf</span> exportDate.sql</div></pre></td></tr></table></figure>
<p>exportData.sql中类似 <code>export to XX.del OF DEL SELECT * FROM XX</code> 语句</p>
<h3 id="源数据库表结构等导出"><a href="#源数据库表结构等导出" class="headerlink" title="源数据库表结构等导出"></a>源数据库表结构等导出</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db2look -d DBname -<span class="selector-tag">a</span> -e -<span class="selector-tag">p</span> -<span class="selector-tag">i</span> userID -w password -o db2look.sql</div></pre></td></tr></table></figure>
<h3 id="重建数据库"><a href="#重建数据库" class="headerlink" title="重建数据库"></a>重建数据库</h3><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> DATABASE DBNAME AUTOMATIC STORAGE NO  <span class="keyword">ON</span> <span class="string">'G:\'</span> <span class="keyword">USING</span> CODESET GBK TERRITORY CN COLLATE <span class="keyword">USING</span> SYSTEM PAGESIZE <span class="number">32768</span> </div><div class="line">    </div><div class="line"><span class="keyword">CREATE</span> BUFFERPOOL CSBP1 IMMEDIATE  SIZE <span class="number">4000</span> PAGESIZE <span class="number">32</span> K </div><div class="line">   </div><div class="line"><span class="keyword">CREATE</span> REGULAR TABLESPACE CS_DATA PAGESIZE <span class="number">32</span> K MANAGED <span class="keyword">BY</span> DATABASE <span class="keyword">USING</span> ( FILE <span class="string">'G:\TBS\tablespace'</span> <span class="number">65536</span> ) EXTENTSIZE <span class="number">32</span> OVERHEAD <span class="number">10.5</span> PREFETCHSIZE <span class="number">32</span> TRANSFERRATE <span class="number">0.14</span> BUFFERPOOL  CSBP1</div><div class="line">   </div><div class="line"></div><div class="line"><span class="keyword">CREATE</span> REGULAR TABLESPACE CS_IDX PAGESIZE <span class="number">32</span> K MANAGED <span class="keyword">BY</span> DATABASE <span class="keyword">USING</span> ( FILE <span class="string">'G:\TBS\indexspace'</span> <span class="number">1310720</span> ) EXTENTSIZE <span class="number">32</span> OVERHEAD <span class="number">10.5</span> PREFETCHSIZE <span class="number">32</span> TRANSFERRATE <span class="number">0.14</span> BUFFERPOOL  CSBP1</div><div class="line">  </div><div class="line"></div><div class="line">GRANTDBADM,CREATETAB,BINDADD,CONNECT,CREATE_NOT_FENCED_ROUTINE,IMPLICIT_SCHEMA,LOAD,CREATE_EXTERNAL_ROUTINE,QUIESCE_CONNECT,SECADM <span class="keyword">ON</span> DATABASE <span class="keyword">TO</span> USER userID</div><div class="line">   </div><div class="line"></div><div class="line">GRANT USE <span class="keyword">OF</span> TABLESPACE CS_DATA <span class="keyword">TO</span> USER ccmsdb <span class="keyword">WITH</span> GRANT OPTION</div></pre></td></tr></table></figure>
<h3 id="本地数据结构恢复"><a href="#本地数据结构恢复" class="headerlink" title="本地数据结构恢复"></a>本地数据结构恢复</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">db2</span> <span class="selector-tag">-tvf</span> <span class="selector-tag">db2look</span><span class="selector-class">.sql</span></div></pre></td></tr></table></figure>
<h3 id="本地数据恢复"><a href="#本地数据恢复" class="headerlink" title="本地数据恢复"></a>本地数据恢复</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">db2</span> <span class="selector-tag">-tf</span> <span class="selector-tag">importDate</span><span class="selector-class">.sql</span></div></pre></td></tr></table></figure>
<p>importDate.sql中类似 <code>import from  XX.del OF DEL replace into XX</code> 语句</p>
<blockquote>
<p><strong>Note:</strong> </p>
<ul>
<li>对于主键自增长型 GENERATED ALWAYS AS IDENTIFY 和 GENERATED BY DEFAULT AS IDENTIFY 数据重新导入时为了不影响原来的自增主键需使用<br><code>load from XX.del of del modified by identityoverride replace into basi_role nonrecoverable</code></li>
</ul>
</blockquote>
<h2 id="碰到的问题"><a href="#碰到的问题" class="headerlink" title="碰到的问题"></a>碰到的问题</h2><h3 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h3><p>现象：数据库安装好后，需安装应用服务器WEBLOGIC,在应用部署到WEBLOGIC上后出现 <code>org.hibernate.QueryException: ClassNotFoundException: org.hibernate.hql.ast.HqlToken</code> 异常</p>
<p>原因：Hibernate3 采用新的基于 antlr 的 HQL/SQL 查询翻译器，在 hibernate3 中需要用到 antlr，然而这个包在 weblogic 中已经包含了 antrl 类库，所以会产生一些类加载的错误，无法找到在 war 或 ear 中的 hibernate3.jar</p>
<p>解决方案：修改 %DOMAIN_HOME%/bin/setDomainEnv.cmd（Linux 为 setDomainEnv.sh），如：D:\Program\weblogic-10.3.6\mydomain\bin\setDomainEnv.cmd，在 set JAVA_HOME 的后面加上set PRE_CLASSPATH=path_of_antlr_jar</p>
<hr>
<h3 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h3><p>现象：不知什么原因在配置DB2数据源选择IBM DB2 TYPE4驱动时填写IP和端口时页面没有此两项输入地方，后台又提示必须输入主机和端口。</p>
<p>原因：未知，删除缓存重启WEBLOGIC也不行</p>
<p>解决方案：采用一个投机取巧的办法：先将安装DB2时安装的DB2驱动放到WEBLOGIC域下lib下面，然后在WEBLOGIC建数据源时选取ORACLE DB2驱动(选择这个无法连接数据库可能还需要原厂商的好使)，<br>然后手动修改IBM DB2的url和驱动类(com.ibm.db2.jcc.DB2Driver)</p>
<hr>
<h3 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h3><p>现象：应用在本地出现未知错误</p>
<p>原因：查看日志发现存在很多java.lang.OutOfMemoryError: PermGen space，内存溢出。使用jvisualvm发现持久代MaxPermSize值只有128MB</p>
<p>解决方案：%DOMAIN_HOME%/bin/setDomainEnv.cmd（Linux 为 setDomainEnv.sh）-Xms1024m -Xmx1024m -XX:PermSize=48m -XX:MaxPermSize=256m </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间公司要求我们项目版本做一次回收，因需要回公司做演示还需要将服务器数据考回到本地–这步比较棘手因为客户方开发环境U盘无法使用=。=，最后好不容易找了个借口&lt;br&gt;向别人搞了个内部U盘。&lt;/p&gt;
&lt;p&gt;我们开发环境为AIX+DB2，因为只需做演示使用数据导出觉定不采用 
    
    </summary>
    
      <category term="database" scheme="https://swinepig.github.io/categories/database/"/>
    
    
      <category term="db2" scheme="https://swinepig.github.io/tags/db2/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC@Response@Request注解简注</title>
    <link href="https://swinepig.github.io/2016/08/08/SpringResponseRequest/"/>
    <id>https://swinepig.github.io/2016/08/08/SpringResponseRequest/</id>
    <published>2016-08-08T13:43:33.000Z</published>
    <updated>2016-09-03T13:49:09.643Z</updated>
    
    <content type="html"><![CDATA[<p>本文对SpringMVC两个注解@Response@Request做一些简单记录</p>
<h3 id="spring-mcv消息转化机制"><a href="#spring-mcv消息转化机制" class="headerlink" title="spring mcv消息转化机制"></a>spring mcv消息转化机制</h3><p>SpringMVC中使用@RequestBody,@ResponseBody注解实现Java对象和XML/JSON数据自动转换，Spring是怎么实现这个转换的呢？我们先了解下Spring的消息转换机制。</p>
<p>在SpringMVC中，可以使用@RequestBody和@ResponseBody两个注解，分别完成请求报文到对象和对象到响应报文的转换，底层这种灵活的消息转换机制，就是Spring3.x中新引入的HttpMessageConverter即消息转换器机制。</p>
<p>我们可以用下面的图，简单描述一下这个过程。</p>
<p><img src="http://swinepig.readthedocs.io/_images/sp_res_req1.jsp" alt="流程图"></p>
<h3 id="Response篇"><a href="#Response篇" class="headerlink" title="@Response篇"></a>@Response篇</h3><p>作用：该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式(xml、json)后，写入到Response对象的body数据区。</p>
<p>使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）</p>
<p>@ResponseBody注解，以及HTTP Request Header中的Accept属性，Controller返回的Java对象可以自动被转换成对应的XML或者JSON数据。</p>
<p>返回XML格式必须满足两个条件要求：</p>
<ul>
<li><p>返回对象的类具有XmlRootElement注解</p>
</li>
<li><p>请求头中的Accept属性包含application/xml</p>
</li>
</ul>
<p>返回json格式我们只要把Jackson2或者GSON加入工程的class path，Spring就会自动把GsonHttpMessageConverter加进来。</p>
<h3 id="RequestBody篇"><a href="#RequestBody篇" class="headerlink" title="RequestBody篇"></a>RequestBody篇</h3><p>作用： </p>
<ul>
<li>该注解用于读取Request请求的body部分数据，使用系统默认配置的HttpMessageConverter进行解析，然后把相应的数据绑定到要返回的对像上</li>
<li>再把HttpMessageConverter返回的对象数据绑定到 controller中方法的参数上。</li>
</ul>
<p>使用时机：</p>
<p>A) GET、POST方式提时， 根据request header Content-Type的值来判断:</p>
<ul>
<li>application/x-www-form-urlencoded， 可选（即非必须，因为这种情况的数据@RequestParam, @ModelAttribute也可以处理，当然@RequestBody也能处理）；</li>
<li>multipart/form-data, 不能处理（即使用@RequestBody不能处理这种格式的数据）；</li>
<li>其他格式， 必须（其他格式包括application/json, application/xml等。这些格式的数据，必须使用@RequestBody来处理）；</li>
</ul>
<p>B) PUT方式提交时， 根据request header Content-Type的值来判断:</p>
<ul>
<li>application/x-www-form-urlencoded， 必须；</li>
<li>multipart/form-data, 不能处理；</li>
<li>其他格式， 必须；</li>
</ul>
<p>说明：request的body部分的数据编码格式由header部分的Content-Type指定</p>
<p>配合@RequestBody注解，以及HTTP Request Header中的Content-Type属性，HTTP Request Body中包含的XML或者JSON数据可以自动被转换成对应的Java对象。</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>MappingJacksonHttpMessageConverter 调用了 objectMapper.writeValue(OutputStream stream, Object)方法，使用@ResponseBody注解返回的对象就传入Object参数内。若返回的对象为已经格式化好的json串时，不使用@RequestBody注解，而应该这样处理：</p>
<p>1、response.setContentType(“application/json; charset=UTF-8”);</p>
<p>2、response.getWriter().print(jsonStr);</p>
<p>直接输出到body区，然后的视图为void。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>根据request header中的Content-Type自动转换XML/JSON-&gt;JAVA对象，如果为application/xml则请求体需xml格式，反之为json格式</p>
<p>根据request header中的Accept自动选择返回XML or JSON (对象需要添加XmlRootElement)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文对SpringMVC两个注解@Response@Request做一些简单记录&lt;/p&gt;
&lt;h3 id=&quot;spring-mcv消息转化机制&quot;&gt;&lt;a href=&quot;#spring-mcv消息转化机制&quot; class=&quot;headerlink&quot; title=&quot;spring mcv消息
    
    </summary>
    
      <category term="java" scheme="https://swinepig.github.io/categories/java/"/>
    
    
      <category term="spring" scheme="https://swinepig.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC整合新浪微博oauth2简例</title>
    <link href="https://swinepig.github.io/2016/08/02/SpringMVCoauth2/"/>
    <id>https://swinepig.github.io/2016/08/02/SpringMVCoauth2/</id>
    <published>2016-08-02T13:25:05.000Z</published>
    <updated>2016-09-03T13:35:29.492Z</updated>
    
    <content type="html"><![CDATA[<p>现在很多网站都整合了便捷的第三方登录，如QQ登录、新浪微博等，为用户提供不少方便和节约时间。</p>
<p>准备阶段</p>
<ul>
<li>搭建好SpringMVC环境</li>
<li>首先申请新浪微博网站接入：<a href="http://open.weibo.com/wiki/" target="_blank" rel="external">http://open.weibo.com/wiki/</a></li>
<li>成为开发者得到App Key和App Secret</li>
<li>下载weibo4j-oauth2SDK：<a href="http://code.google.com/p/weibo4j/downloads/list" target="_blank" rel="external">http://code.google.com/p/weibo4j/downloads/list</a></li>
</ul>
<p>下载解压后，将src目录下weibo4j文件夹以及config.properties拷贝至自己 JAVA WEB 项目的src目录下(也可以把src下的源码打成jar包)。</p>
<p>编辑config.properties配置文件，改成成自己的资料。第一个填写你申请的App Key值，第二个填写App Secret值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">client_ID =     </div><div class="line">client_SERCRET =</div><div class="line">redirect_URI =</div></pre></td></tr></table></figure>
<p>第三个redirect_URI，是你的重定向后的网址。应该对应一个控制器（Spring Controller）或 Servlet。在这里我们需要两个网址，第一个网址即用户在页面上点击的网址，能跳转到新浪微博账号登录界面，当用户点击账号登陆界面的登录按钮时，新浪微博会去校验资料正确性，一旦资料正确将会以 get 方式请求并且携带参数code重定向到你填写的redirect_URI，此时就能获取用户的资料了。</p>
<p>假如首先用户点击 <a href="http://localhost/api/weibo/login1，我们接收请求后主要工作是重定向到新浪微博登录页面。代码片段如下：" target="_blank" rel="external">http://localhost/api/weibo/login1，我们接收请求后主要工作是重定向到新浪微博登录页面。代码片段如下：</a>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line">   <span class="comment">/***</span></div><div class="line">	 * 新浪微博登录界面</div><div class="line">	 * <span class="doctag">@param</span> request</div><div class="line">	 * <span class="doctag">@param</span> session</div><div class="line">	 * <span class="doctag">@return</span></div><div class="line">	 * <span class="doctag">@throws</span> WeiboException</div><div class="line">	 */</div><div class="line">	<span class="meta">@RequestMapping</span>(value=<span class="string">"/weibo/login1"</span>,method=RequestMethod.GET)</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">loginSinaWeibo</span><span class="params">(HttpServletRequest request, HttpSession session)</span> <span class="keyword">throws</span> WeiboException</span>&#123;</div><div class="line">		session.setAttribute(<span class="string">"login_current_url"</span>, request.getHeader(<span class="string">"Referer"</span>));</div><div class="line">		weibo4j.Oauth oauth = <span class="keyword">new</span> weibo4j.Oauth();</div><div class="line">		String url = oauth.authorize(<span class="string">"code"</span>);</div><div class="line">		logger.info(<span class="string">"新浪微博登录界面，重定向至:"</span>+url);</div><div class="line">        <span class="keyword">return</span> <span class="string">"redirect:"</span> + url;</div><div class="line">	&#125;</div><div class="line">```	</div><div class="line">代码片段中的session是为了获取用户登录前所在页面URL，方便登录完后重定向到登录之前的页面。其中url是新浪微博登录界面网址，我们只需要重定向过去就行了。</div><div class="line"></div><div class="line">当用户在新浪微博登录成功后，会重定向到我们刚才填写的redirect_URI中，如我填写的 http:<span class="comment">//xxx.xxx.xxx.xx/api/weibo/login1，对应逻辑代码片段如下：</span></div><div class="line"></div><div class="line">``` java</div><div class="line">  <span class="comment">/**</span></div><div class="line">     * </div><div class="line">     * 新浪微博登录操作</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> session</div><div class="line">     *  <span class="doctag">@return</span></div><div class="line">     * <span class="doctag">@throws</span> WeiboException</div><div class="line">     */</div><div class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/weibo/login2"</span>, method = RequestMethod.GET)</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">loginSinaWeiboAction</span><span class="params">(HttpSession session,</span></span></div><div class="line">            @RequestParam String code) <span class="keyword">throws</span> WeiboException &#123;</div><div class="line">        String url = (String) session.getAttribute(<span class="string">"login_current_url"</span>);</div><div class="line">        session.removeAttribute(<span class="string">"login_current_url"</span>);</div><div class="line">        User user = sinaWeiboLoginAction(code,</div><div class="line">                (User) session.getAttribute(<span class="string">"user"</span>));</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != user) &#123;</div><div class="line">            session.setAttribute(<span class="string">"user"</span>, user);</div><div class="line">        &#125;</div><div class="line">        logger.info(<span class="string">"新浪微博登录操作，重定向至:"</span>+url);</div><div class="line">        <span class="keyword">return</span> <span class="string">"redirect:/api/zhongjulin"</span>;</div><div class="line">    &#125;</div><div class="line">```    </div><div class="line">重定向过来会携带code参数我们把值取到用来获取用户的资料。获取了code然后得到access_token就能操作API了</div><div class="line"></div><div class="line">``` java</div><div class="line">   <span class="comment">/**</span></div><div class="line">     * 新浪微博操作</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> code</div><div class="line">     * <span class="doctag">@param</span> currentLoginUser</div><div class="line">     *            当前登录用户，可为 null</div><div class="line">     *  <span class="doctag">@return</span></div><div class="line">     * <span class="doctag">@throws</span> WeiboException</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> User <span class="title">sinaWeiboLoginAction</span><span class="params">(String code, User currentLoginUser)</span></span></div><div class="line">            <span class="keyword">throws</span> WeiboException &#123;</div><div class="line">        weibo4j.Oauth oauth = <span class="keyword">new</span> weibo4j.Oauth();</div><div class="line">        weibo4j.http.AccessToken accessToken = oauth.getAccessTokenByCode(code);</div><div class="line">        String uid = accessToken.getUserUid();</div><div class="line">        weibo4j.Users users = <span class="keyword">new</span> weibo4j.Users(accessToken.getAccessToken());</div><div class="line">        weibo4j.model.User user = users.showUserById(uid);</div><div class="line">        String userDomain = user.getUserDomain(); <span class="comment">// 用户登录名</span></div><div class="line">        String c = user.getScreenName(); <span class="comment">// 用户呢称</span></div><div class="line">        String avatar = user.getAvatarLarge(); <span class="comment">// 用户头像</span></div><div class="line">        String gender = <span class="keyword">null</span>; <span class="comment">// 性别</span></div><div class="line">        <span class="keyword">if</span> (<span class="string">"m"</span>.equals(user.getGender())) &#123;</div><div class="line">            gender = <span class="string">"femal"</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"f"</span>.equals(user.getGender())) &#123;</div><div class="line">            gender = <span class="string">"male"</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            gender = <span class="string">"未知"</span>;</div><div class="line">        &#125;</div><div class="line">        logger.info(<span class="string">"userDomain: "</span>+userDomain+<span class="string">"ScreenName: "</span>+c);</div><div class="line">        <span class="comment">// …… 业务逻辑操作，代码略</span></div><div class="line">        <span class="keyword">return</span> currentLoginUser;</div><div class="line">    &#125;</div><div class="line">```    </div><div class="line">其中String uid = accessToken.getUserUid();</div><div class="line"></div><div class="line">getUserUid()方法本身是没有的，我们需要修改新浪微博的源代码，不然取uid非常麻烦。</div><div class="line"></div><div class="line">编辑/src/weibo4j.http/AccessToken.java，在：</div><div class="line"></div><div class="line">``` <span class="function">java</span></div><div class="line">   <span class="keyword">public</span> String <span class="title">getRefreshToken</span><span class="params">()</span> &#123;</div><div class="line">    <span class="keyword">return</span> refreshToken;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>下面添加：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUserUid</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> uid;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在很多网站都整合了便捷的第三方登录，如QQ登录、新浪微博等，为用户提供不少方便和节约时间。&lt;/p&gt;
&lt;p&gt;准备阶段&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;搭建好SpringMVC环境&lt;/li&gt;
&lt;li&gt;首先申请新浪微博网站接入：&lt;a href=&quot;http://open.weibo.c
    
    </summary>
    
      <category term="java" scheme="https://swinepig.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>java中Pattern.compile函数的相关解释</title>
    <link href="https://swinepig.github.io/2016/07/12/Pattern/"/>
    <id>https://swinepig.github.io/2016/07/12/Pattern/</id>
    <published>2016-07-12T13:38:16.000Z</published>
    <updated>2016-09-03T13:43:00.774Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Pattern.compile函数：Pattern Pattern.compile(String regex, <span class="keyword">int</span> flag)</div></pre></td></tr></table></figure>
<p>flag的取值范围如下：</p>
<p>Pattern.CANON_EQ，当且仅当两个字符的”正规分解(canonical decomposition)”都完全相同的情况下，才认定匹配。比如用了这个标志之后，表达式”a\u030A”会匹配”?”。默认情况下，不考虑”规范相等性(canonical equivalence)”。</p>
<p>Pattern.CASE_INSENSITIVE(?i) 默认情况下，大小写不敏感的匹配只适用于US-ASCII字符集。这个标志能让表达式忽略大小写进行匹配。要想对Unicode字符进行大小不明感的匹 配，只要将UNICODE_CASE与这个标志合起来就行了。</p>
<p>Pattern.COMMENTS(?x) 在这种模式下，匹配时会忽略(正则表达式里的)空格字符(不是指表达式里的”\s”，而是指表达式里的空格，tab，回车之类)。注释从#开始，一直到这行结束。可以通过嵌入式的标志来启用Unix行模式。</p>
<p>Pattern.DOTALL(?s) 在这种模式下，表达式’.’可以匹配任意字符，包括表示一行的结束符。默认情况下，表达式’.’不匹配行的结束符。</p>
<p>Pattern.MULTILINE(?m)在这种模式下，’^’和’$’分别匹配一行的开始和结束。此外，’^’仍然匹配字符串的开始，’$’也匹配字符串的结束。默认情况下，这两个表达式仅仅匹配字符串的开始和结束。</p>
<p>Pattern.UNICODE_CASE(?u) 在这个模式下，如果你还启用了CASE_INSENSITIVE标志，那么它会对Unicode字符进行大小写不明感的匹配。默认情况下，大小写不敏感的匹配只适用于US-ASCII字符集。</p>
<p>Pattern.UNIX_LINES(?d) 在这个模式下，只有’\n’才被认作一行的中止，并且与’.’，’^’，以及’$’进行匹配。</p>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line
    
    </summary>
    
      <category term="java" scheme="https://swinepig.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>Jedis2.1之ShardedJedisPool分析</title>
    <link href="https://swinepig.github.io/2015/11/27/ShardedJedisPool/"/>
    <id>https://swinepig.github.io/2015/11/27/ShardedJedisPool/</id>
    <published>2015-11-27T13:34:59.000Z</published>
    <updated>2016-09-03T13:37:18.901Z</updated>
    
    <content type="html"><![CDATA[<p>Jedis2.1之ShardedJedisPool分析</p>
<blockquote>
<p><strong>note</strong></p>
<ul>
<li>此版本ShardedJedisPool适用于Jedis2.1版本，reids 2.6版本依赖的jar包：commons-collections.jar和commons-pool.jar</li>
</ul>
</blockquote>
<p><code>Jedis</code> 作为推荐的java语言redis客户端，ShardedJedis是基于一致性哈希算法实现的分布式Redis集群客户端。</p>
<p>先来看一段获取ShardedJedis对象的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">List&lt;JedisShardInfo&gt; shards = <span class="keyword">new</span> ArrayList&lt;JedisShardInfo&gt;();</div><div class="line">shards.add(<span class="keyword">new</span> JedisShardInfo(redis1.host, redis1.port));</div><div class="line">shards.add(<span class="keyword">new</span> JedisShardInfo(redis2.host, redis2.port));</div><div class="line">shards.get(<span class="number">0</span>).setPassword(<span class="string">"foobared"</span>);</div><div class="line">shards.get(<span class="number">1</span>).setPassword(<span class="string">"foobared"</span>);</div><div class="line">ShardedJedisPool pool = <span class="keyword">new</span> ShardedJedisPool(<span class="keyword">new</span> Config(), shards);</div><div class="line">ShardedJedis jedis = pool.getResource();</div><div class="line">jedis.disconnect();</div><div class="line">pool.returnBrokenResource(jedis);</div><div class="line"></div><div class="line">jedis = pool.getResource();</div><div class="line">jedis.incr(<span class="string">"foo"</span>);</div><div class="line">pool.returnResource(jedis);</div><div class="line">pool.destroy();</div></pre></td></tr></table></figure>
<p>ShardedJedis这个对象通过ShardedJedisPool来创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ShardedJedisPool pool = <span class="keyword">new</span> ShardedJedisPool(<span class="keyword">final</span> GenericObjectPool.Config poolConfig,List&lt;JedisShardInfo&gt; shards)</div></pre></td></tr></table></figure>
<p>第二个参数shards就是所有节点信息的集合包括：节点IP，监听port，密码password。最后参数和另外两个参数一起构建一个ShardedJedisFactory对象(为ShardedJedisPool私有内部对象)，ShardedJedis就是<br>从这个工厂对象里生产的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ShardedJedisPool</span><span class="params">(<span class="keyword">final</span> GenericObjectPool.Config poolConfig,</span></span></div><div class="line">        List&lt;JedisShardInfo&gt; shards, Hashing algo, Pattern keyTagPattern) &#123;</div><div class="line">    <span class="keyword">super</span>(poolConfig, <span class="keyword">new</span> ShardedJedisFactory(shards, algo, keyTagPattern));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jedis = pool.getResource();</div></pre></td></tr></table></figure>
<p>可以看出jedis对象是从池中获取的，分析代码可知pool.getResource()-&gt;internalPool.borrowObject()-&gt;factory.makeObject()。最后通过上面创建的ShardedJedisFactory对象<br>的makeObject()方法得到了ShardedJedis对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">makeObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">         ShardedJedis jedis = <span class="keyword">new</span> ShardedJedis(shards, algo, keyTagPattern);</div><div class="line">         <span class="keyword">return</span> jedis;</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<p>构建ShardedJedis对象时进行了一步初始化操作，通过一致性哈希算法将所有节点(server)散列开来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(List&lt;S&gt; shards)</span> </span>&#123;</div><div class="line">     nodes = <span class="keyword">new</span> TreeMap&lt;Long, S&gt;();</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != shards.size(); ++i) &#123;</div><div class="line">         <span class="keyword">final</span> S shardInfo = shards.get(i);</div><div class="line">         <span class="keyword">if</span> (shardInfo.getName() == <span class="keyword">null</span>)</div><div class="line">         	<span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; <span class="number">160</span> * shardInfo.getWeight(); n++) &#123;</div><div class="line">         		nodes.put(<span class="keyword">this</span>.algo.hash(<span class="string">"SHARD-"</span> + i + <span class="string">"-NODE-"</span> + n), shardInfo);</div><div class="line">         	&#125;</div><div class="line">         <span class="keyword">else</span></div><div class="line">         	<span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; <span class="number">160</span> * shardInfo.getWeight(); n++) &#123;</div><div class="line">         		nodes.put(<span class="keyword">this</span>.algo.hash(shardInfo.getName() + <span class="string">"*"</span> + shardInfo.getWeight() + n), shardInfo);</div><div class="line">         	&#125;</div><div class="line">         resources.put(shardInfo, shardInfo.createResource());</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>note</strong></p>
<ul>
<li>Redis服务器节点划分：将每台服务器节点采用hash算法划分为160个虚拟节点(可以配置划分权重)</li>
<li>将划分虚拟节点采用TreeMap存储</li>
<li>对每个Redis服务器的物理连接采用LinkedHashMap存储</li>
<li>对Key or KeyTag 采用同样的hash算法，然后从TreeMap获取大于等于键hash值得节点，取最邻近节点存储；当key的hash值大于虚拟节点hash值得最大值时，存入第一个虚拟节点</li>
<li>sharded采用的hash算法：MD5 和 MurmurHash两种；默认采用64位的MurmurHash算法；MurmurHash是一种高效，低碰撞的hash算法</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">jedis.incr(<span class="string">"foo"</span>);</div><div class="line"></div><div class="line"><span class="comment">//incr方法</span></div><div class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">incr</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">Jedis j = getShard(key);</div><div class="line"><span class="keyword">return</span> j.incr(key);</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">set</span><span class="params">(String key, String value)</span> </span>&#123;</div><div class="line">	Jedis j = getShard(key);</div><div class="line">  <span class="keyword">return</span> j.set(key, value);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">Jedis j = getShard(key);</div><div class="line">  <span class="keyword">return</span> j.get(key);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>所以可以看到最终还是通过Jedis对象来和redis通信.</p>
<p>getShard方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> R <span class="title">getShard</span><span class="params">(<span class="keyword">byte</span>[] key)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> resources.get(getShardInfo(key));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>getShardInfo方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> S <span class="title">getShardInfo</span><span class="params">(<span class="keyword">byte</span>[] key)</span> </span>&#123;</div><div class="line">    SortedMap&lt;Long, S&gt; tail = nodes.tailMap(algo.hash(key));</div><div class="line">    <span class="keyword">if</span> (tail.isEmpty()) &#123;</div><div class="line">        <span class="keyword">return</span> nodes.get(nodes.firstKey());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> tail.get(tail.firstKey());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Jedis2.1之ShardedJedisPool分析&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;note&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;此版本ShardedJedisPool适用于Jedis2.1版本，reids 2.6版本依赖的jar包：co
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap</title>
    <link href="https://swinepig.github.io/2015/11/27/ConcurrentHashMap/"/>
    <id>https://swinepig.github.io/2015/11/27/ConcurrentHashMap/</id>
    <published>2015-11-27T12:07:58.000Z</published>
    <updated>2016-09-03T12:48:55.992Z</updated>
    
    <content type="html"><![CDATA[<p>ConcurrentHashMap是Java 5中支持高并发、高吞吐量的线程安全HashMap实现</p>
<h3 id="锁分离-Lock-Stripping"><a href="#锁分离-Lock-Stripping" class="headerlink" title="锁分离 (Lock Stripping)"></a>锁分离 (Lock Stripping)</h3><p>ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术。它使用了多个锁来控制对hash表的不同部分进行的修改。ConcurrentHashMap内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的hash table，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。</p>
<p>有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。这里“按顺序”是很重要的，否则极有可能出现死锁，在ConcurrentHashMap内部，段数组是final的，并且其成员变量实际上也是final的，但是，仅仅是将数组声明为final的并不保证数组成员也是final的，这需要实现上的保证。这可以确保不会出现死锁，因为获得锁的顺序是固定的。不变性是多线程编程占有很重要的地位，下面还要谈到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * The segments, each of which is a specialized       hash table</div><div class="line">*/</div><div class="line"> <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</div></pre></td></tr></table></figure>
<h3 id="不变-Immutable-和易变-Volatile"><a href="#不变-Immutable-和易变-Volatile" class="headerlink" title="不变(Immutable)和易变(Volatile)"></a>不变(Immutable)和易变(Volatile)</h3><p>ConcurrentHashMap完全允许多个读操作并发进行，读操作并不需要加锁。如果使用传统的技术，如HashMap中的实现，如果允许可以在hash链的中间添加或删除元素，读操作不加锁将得到不一致的数据。ConcurrentHashMap实现技术是保证HashEntry几乎是不可变的。HashEntry代表每个hash链中的一个节点，其结构如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">     <span class="keyword">final</span> K key;</div><div class="line">     <span class="keyword">final</span> <span class="keyword">int</span> hash;</div><div class="line">     <span class="keyword">volatile</span> V value;</div><div class="line">     <span class="keyword">final</span> HashEntry&lt;K,V&gt; next;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以看到除了value不是final的，其它值都是final的，这意味着不能从hash链的中间或尾部添加或删除节点，因为这需要修改next引用值，所有的节点的修改只能从头部开始。对于put操作，可以一律添加到Hash链的头部。但是对于remove操作，可能需要从中间删除一个节点，这就需要将要删除节点的前面所有节点整个复制一遍，最后一个节点指向要删除结点的下一个结点。这在讲解删除操作时还会详述。为了确保读操作能够看到最新的值，将value设置成volatile，这避免了加锁。</p>
<p>这是重新hash的算法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</div><div class="line"><span class="comment">// Spread bits to regularize both segment and index locations,</span></div><div class="line"><span class="comment">// using variant of single-word Wang/Jenkins hash.</span></div><div class="line">      h += (h &lt;&lt;  <span class="number">15</span>) ^ <span class="number">0xffffcd7d</span>;</div><div class="line">      h ^= (h &gt;&gt;&gt; <span class="number">10</span>);</div><div class="line">      h += (h &lt;&lt;   <span class="number">3</span>);</div><div class="line">      h ^= (h &gt;&gt;&gt;  <span class="number">6</span>);</div><div class="line">      h += (h &lt;&lt;   <span class="number">2</span>) + (h &lt;&lt; <span class="number">14</span>);</div><div class="line">      <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是定位段的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> Segment&lt;K,V&gt; <span class="title">segmentFor</span><span class="params">(<span class="keyword">int</span> hash)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask];</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>关于Hash表的基础数据结构，这里不想做过多的探讨。Hash表的一个很重要方面就是如何解决hash冲突，ConcurrentHashMap和HashMap使用相同的方式，都是将hash值相同的节点放在一个hash链中。与HashMap不同的是，ConcurrentHashMap使用多个子Hash表，也就是段(Segment)。下面是ConcurrentHashMap的数据成员：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;<span class="keyword">implements</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;, <span class="title">Serializable</span> </span>&#123;</div><div class="line"> <span class="comment">/**</span></div><div class="line">  * Mask value for indexing into segments. The upper bits of a</div><div class="line">  * key's hash code are used to choose the segment.</div><div class="line">  */</div><div class="line"> <span class="keyword">final</span> <span class="keyword">int</span> segmentMask;</div><div class="line"></div><div class="line"> <span class="comment">/**</span></div><div class="line">  * Shift value for indexing within segments.</div><div class="line">  */</div><div class="line"> <span class="keyword">final</span> <span class="keyword">int</span> segmentShift;</div><div class="line"></div><div class="line"> <span class="comment">/**</span></div><div class="line">  * The segments, each of which is a specialized hash table</div><div class="line">  */</div><div class="line"> <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所有的成员都是final的，其中segmentMask和segmentShift主要是为了定位段，参见上面的segmentFor方法。</p>
<p>每个Segment相当于一个子Hash表，它的数据成员如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2249069246763182397L</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The number of elements in this segment's region.</div><div class="line">     */</div><div class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Number of updates that alter the size of the table. This is</div><div class="line">     * used during bulk-read methods to make sure they see a</div><div class="line">     * consistent snapshot: If modCounts change during a traversal</div><div class="line">     * of segments computing size or checking containsValue, then</div><div class="line">     * we might have an inconsistent view of state so (usually)</div><div class="line">     * must retry.</div><div class="line">     */</div><div class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The table is rehashed when its size exceeds this threshold.</div><div class="line">     * (The value of this field is always &lt;tt&gt;(int)(capacity *</div><div class="line">     * loadFactor)&lt;/tt&gt;.)</div><div class="line">     */</div><div class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> threshold;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The per-segment table.</div><div class="line">     */</div><div class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The load factor for the hash table.  Even though this value</div><div class="line">     * is same for all segments, it is replicated to avoid needing</div><div class="line">     * links to outer object.</div><div class="line">     * <span class="doctag">@serial</span></div><div class="line">     */</div><div class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>count用来统计该段数据的个数，它是volatile，它用来协调修改和读取操作，以保证读取操作能够读取到几乎最新的修改。协调方式是这样的，每次修改操作做了结构上的改变，如增加/删除节点(修改节点的值不算结构上的改变)，都要写count值，每次读取操作开始都要读取count的值。这利用了Java 5中对volatile语义的增强，对同一个volatile变量的写和读存在happens-before关系。modCount统计段结构改变的次数，主要是为了检测对多个段进行遍历过程中某个段是否发生改变，在讲述跨段操作时会还会详述。threashold用来表示需要进行rehash的界限值。table数组存储段中节点，每个数组元素是个hash链，用HashEntry表示。table也是volatile，这使得能够读取到最新的table值而不需要同步。loadFactor表示负载因子。</p>
<h3 id="修改操作"><a href="#修改操作" class="headerlink" title="修改操作"></a>修改操作</h3><p>先来看下删除操作remove(key)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">	    <span class="keyword">int</span> hash = hash(key.hashCode());</div><div class="line">      <span class="keyword">return</span> segmentFor(hash).remove(key, hash, <span class="keyword">null</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>整个操作是先定位到段，然后委托给段的remove操作。当多个删除操作并发进行时，只要它们所在的段不相同，它们就可以同时进行。下面是Segment的remove方法实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function">V <span class="title">remove</span><span class="params">(Object key, <span class="keyword">int</span> hash, Object value)</span> </span>&#123;</div><div class="line">    lock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">int</span> c = count - <span class="number">1</span>;</div><div class="line">        HashEntry&lt;K,V&gt;[] tab = table;</div><div class="line">        <span class="keyword">int</span> index = hash &amp; (tab.length - <span class="number">1</span>);</div><div class="line">        HashEntry&lt;K,V&gt; first = tab[index];</div><div class="line">        HashEntry&lt;K,V&gt; e = first;</div><div class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span> &amp;&amp; (e.hash != hash || !key.equals(e.key)))</div><div class="line">            e = e.next;</div><div class="line"></div><div class="line">        V oldValue = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">            V v = e.value;</div><div class="line">            <span class="keyword">if</span> (value == <span class="keyword">null</span> || value.equals(v)) &#123;</div><div class="line">                oldValue = v;</div><div class="line">                <span class="comment">// All entries following removed node can stay</span></div><div class="line">                <span class="comment">// in list, but all preceding ones need to be</span></div><div class="line">                <span class="comment">// cloned.</span></div><div class="line">                ++modCount;</div><div class="line">                HashEntry&lt;K,V&gt; newFirst = e.next;</div><div class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = first; p != e; p = p.next)</div><div class="line">                    newFirst = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(p.key, p.hash,</div><div class="line">                                                  newFirst, p.value);</div><div class="line">                tab[index] = newFirst;</div><div class="line">                count = c; <span class="comment">// write-volatile</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> oldValue;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>整个操作是在持有段锁的情况下执行的，空白行之前的行主要是定位到要删除的节点e。接下来，如果不存在这个节点就直接返回null，否则就要将e前面的结点复制一遍，尾结点指向e的下一个结点。e后面的结点不需要复制，它们可以重用</p>
<p>整个remove实现并不复杂，但是需要注意如下几点。第一，当要删除的结点存在时，删除的最后一步操作要将count的值减一。这必须是最后一步操作，否则读取操作可能看不到之前对段所做的结构性修改。第二，remove执行的开始就将table赋给一个局部变量tab，这是因为table是volatile变量，读写volatile变量的开销很大。编译器也不能对volatile变量的读写做任何优化，直接多次访问非volatile实例变量没有多大影响，编译器会做相应优化。</p>
<p>接下来看put操作，同样地put操作也是委托给段的put方法。下面是段的put方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function">V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</div><div class="line">    lock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">int</span> c = count;</div><div class="line">        <span class="keyword">if</span> (c++ &gt; threshold) <span class="comment">// ensure capacity</span></div><div class="line">            rehash();</div><div class="line">        HashEntry&lt;K,V&gt;[] tab = table;</div><div class="line">        <span class="keyword">int</span> index = hash &amp; (tab.length - <span class="number">1</span>);</div><div class="line">        HashEntry&lt;K,V&gt; first = tab[index];</div><div class="line">        HashEntry&lt;K,V&gt; e = first;</div><div class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span> &amp;&amp; (e.hash != hash || !key.equals(e.key)))</div><div class="line">            e = e.next;</div><div class="line"></div><div class="line">        V oldValue;</div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">            oldValue = e.value;</div><div class="line">            <span class="keyword">if</span> (!onlyIfAbsent)</div><div class="line">                e.value = value;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            oldValue = <span class="keyword">null</span>;</div><div class="line">            ++modCount;</div><div class="line">            tab[index] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(key, hash, first, value);</div><div class="line">            count = c; <span class="comment">// write-volatile</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> oldValue;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法也是在持有段锁的情况下执行的，首先判断是否需要rehash，需要就先rehash。接着是找是否存在同样一个key的结点，如果存在就直接替换这个结点的值。否则创建一个新的结点并添加到hash链的头部，这时一定要修改modCount和count的值，同样修改count的值一定要放在最后一步。put方法调用了rehash方法，reash方法实现得也很精巧，主要利用了table的大小为2^n，这里就不介绍了。</p>
<p>修改操作还有putAll和replace。putAll就是多次调用put方法，没什么好说的。replace甚至不用做结构上的更改，实现要比put和delete要简单得多，理解了put和delete，理解replace就不在话下了，这里也不介绍了。</p>
<h3 id="获取操作"><a href="#获取操作" class="headerlink" title="获取操作"></a>获取操作</h3><p>首先看下get操作，同样ConcurrentHashMap的get操作是直接委托给Segment的get方法，直接看Segment的get方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function">V <span class="title">get</span><span class="params">(Object key, <span class="keyword">int</span> hash)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (count != <span class="number">0</span>) &#123; <span class="comment">// read-volatile</span></div><div class="line">        HashEntry&lt;K,V&gt; e = getFirst(hash);</div><div class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; key.equals(e.key)) &#123;</div><div class="line">                V v = e.value;</div><div class="line">                <span class="keyword">if</span> (v != <span class="keyword">null</span>)</div><div class="line">                    <span class="keyword">return</span> v;</div><div class="line">                <span class="keyword">return</span> readValueUnderLock(e); <span class="comment">// recheck</span></div><div class="line">            &#125;</div><div class="line">            e = e.next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>get操作不需要锁。第一步是访问count变量，这是一个volatile变量，由于所有的修改操作在进行结构修改时都会在最后一步写count变量，通过这种机制保证get操作能够得到几乎最新的结构更新。对于非结构更新，也就是结点值的改变，由于HashEntry的value变量是volatile的，也能保证读取到最新的值。接下来就是对hash链进行遍历找到要获取的结点，如果没有找到，直接访回null。对hash链进行遍历不需要加锁的原因在于链指针next是final的。但是头指针却不是final的，这是通过getFirst(hash)方法返回，也就是存在table数组中的值。这使得getFirst(hash)可能返回过时的头结点，例如，当执行get方法时，刚执行完getFirst(hash)之后，另一个线程执行了删除操作并更新头结点，这就导致get方法中返回的头结点不是最新的。这是可以允许，通过对count变量的协调机制，get能读取到几乎最新的数据，虽然可能不是最新的。要得到最新的数据，只有采用完全的同步。</p>
<p>最后，如果找到了所求的结点，判断它的值如果非空就直接返回，否则在有锁的状态下再读一次。这似乎有些费解，理论上结点的值不可能为空，这是因为put的时候就进行了判断，如果为空就要抛NullPointerException。空值的唯一源头就是HashEntry中的默认值，因为HashEntry中的value不是final的，非同步读取有可能读取到空值。仔细看下put操作的语句：tab[index] = new HashEntry<k,v>(key, hash, first, value)，在这条语句中，HashEntry构造函数中对value的赋值以及对tab[index]的赋值可能被重新排序，这就可能导致结点的值为空。这种情况应当很罕见，一旦发生这种情况，ConcurrentHashMap采取的方式是在持有锁的情况下再读一遍，这能够保证读到最新的值，并且一定不会为空值。</k,v></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function">V <span class="title">readValueUnderLock</span><span class="params">(HashEntry&lt;K,V&gt; e)</span> </span>&#123;</div><div class="line">        lock();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">return</span> e.value;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>另一个操作是containsKey，这个实现就要简单得多了，因为它不需要读取值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key, <span class="keyword">int</span> hash)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (count != <span class="number">0</span>) &#123; <span class="comment">// read-volatile</span></div><div class="line">        HashEntry&lt;K,V&gt; e = getFirst(hash);</div><div class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; key.equals(e.key))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            e = e.next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="跨段操作"><a href="#跨段操作" class="headerlink" title="跨段操作"></a>跨段操作</h3><p>有些操作需要涉及到多个段，比如说size(), containsValaue()。先来看下size()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</div><div class="line">    <span class="keyword">long</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">long</span> check = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span>[] mc = <span class="keyword">new</span> <span class="keyword">int</span>[segments.length];</div><div class="line">    <span class="comment">// Try a few times to get accurate count. On failure due to</span></div><div class="line">    <span class="comment">// continuous async changes in table, resort to locking.</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; RETRIES_BEFORE_LOCK; ++k) &#123;</div><div class="line">        check = <span class="number">0</span>;</div><div class="line">        sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> mcsum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; segments.length; ++i) &#123;</div><div class="line">            sum += segments[i].count;</div><div class="line">            mcsum += mc[i] = segments[i].modCount;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (mcsum != <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; segments.length; ++i) &#123;</div><div class="line">                check += segments[i].count;</div><div class="line">                <span class="keyword">if</span> (mc[i] != segments[i].modCount) &#123;</div><div class="line">                    check = -<span class="number">1</span>; <span class="comment">// force retry</span></div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (check == sum)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (check != sum) &#123; <span class="comment">// Resort to locking all segments</span></div><div class="line">        sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; segments.length; ++i)</div><div class="line">            segments[i].lock();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; segments.length; ++i)</div><div class="line">            sum += segments[i].count;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; segments.length; ++i)</div><div class="line">            segments[i].unlock();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (sum &gt; Integer.MAX_VALUE)</div><div class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>size方法主要思路是先在没有锁的情况下对所有段大小求和，如果不能成功（这是因为遍历过程中可能有其它线程正在对已经遍历过的段进行结构性更新），最多执行RETRIES_BEFORE_LOCK次，如果还不成功就在持有所有段锁的情况下再对所有段大小求和。在没有锁的情况下主要是利用Segment中的modCount进行检测，在遍历过程中保存每个Segment的modCount，遍历完成之后再检测每个Segment的modCount有没有改变，如果有改变表示有其它线程正在对Segment进行结构性并发更新，需要重新计算。</p>
<p>其实这种方式是存在问题的，在第一个内层for循环中，在这两条语句sum += segments[i].count; mcsum += mc[i] = segments[i].modCount;之间，其它线程可能正在对Segment进行结构性的修改，导致segments[i].count和segments[i].modCount读取的数据并不一致。这可能使size()方法返回任何时候都不曾存在的大小，很奇怪javadoc居然没有明确标出这一点，可能是因为这个时间窗口太小了吧。size()的实现还有一点需要注意，必须要先segments[i].count，才能segments[i].modCount，这是因为segment[i].count是对volatile变量的访问，接下来segments[i].modCount才能得到几乎最新的值（前面我已经说了为什么只是“几乎”了）。这点在containsValue方法中得到了淋漓尽致的展现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line"></div><div class="line">    <span class="comment">// See explanation of modCount use above</span></div><div class="line"></div><div class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</div><div class="line">    <span class="keyword">int</span>[] mc = <span class="keyword">new</span> <span class="keyword">int</span>[segments.length];</div><div class="line"></div><div class="line">    <span class="comment">// Try a few times without locking</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; RETRIES_BEFORE_LOCK; ++k) &#123;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> mcsum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; segments.length; ++i) &#123;</div><div class="line">            <span class="keyword">int</span> c = segments[i].count;</div><div class="line">            mcsum += mc[i] = segments[i].modCount;</div><div class="line">            <span class="keyword">if</span> (segments[i].containsValue(value))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">boolean</span> cleanSweep = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span> (mcsum != <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; segments.length; ++i) &#123;</div><div class="line">                <span class="keyword">int</span> c = segments[i].count;</div><div class="line">                <span class="keyword">if</span> (mc[i] != segments[i].modCount) &#123;</div><div class="line">                    cleanSweep = <span class="keyword">false</span>;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (cleanSweep)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// Resort to locking all segments</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; segments.length; ++i)</div><div class="line">        segments[i].lock();</div><div class="line">    <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; segments.length; ++i) &#123;</div><div class="line">            <span class="keyword">if</span> (segments[i].containsValue(value)) &#123;</div><div class="line">                found = <span class="keyword">true</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; segments.length; ++i)</div><div class="line">            segments[i].unlock();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> found;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样注意内层的第一个for循环，里面有语句int c = segments[i].count; 但是c却从来没有被使用过，即使如此，编译器也不能做优化将这条语句去掉，因为存在对volatile变量count的读取，这条语句存在的唯一目的就是保证segments[i].modCount读取到几乎最新的值。关于containsValue方法的其它部分就不分析了，它和size方法差不多。</p>
<p>跨段方法中还有一个isEmpty()方法，其实现比size()方法还要简单，也不介绍了。最后简单地介绍下迭代方法，如keySet(), values(), entrySet()方法，这些方法都返回相应的迭代器，所有迭代器都继承于Hash_Iterator类(提交时居然提醒我不能包含sh It，只得加了下划线)，里实现了主要的方法。其结构是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Hash_Iterator</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> nextSegmentIndex;</div><div class="line">    <span class="keyword">int</span> nextTableIndex;</div><div class="line">    HashEntry&lt;K,V&gt;[] currentTable;</div><div class="line">    HashEntry&lt;K, V&gt; nextEntry;</div><div class="line">    HashEntry&lt;K, V&gt; lastReturned;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>nextSegmentIndex是段的索引，nextTableIndex是nextSegmentIndex对应段中中hash链的索引，currentTable是nextSegmentIndex对应段的table。调用next方法时主要是调用了advance方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">advance</span><span class="params">()</span> </span>&#123;</div><div class="line">     <span class="keyword">if</span> (nextEntry != <span class="keyword">null</span> &amp;&amp; (nextEntry = nextEntry.next) != <span class="keyword">null</span>)</div><div class="line">         <span class="keyword">return</span>;</div><div class="line"></div><div class="line">     <span class="keyword">while</span> (nextTableIndex &gt;= <span class="number">0</span>) &#123;</div><div class="line">         <span class="keyword">if</span> ( (nextEntry = currentTable[nextTableIndex--]) != <span class="keyword">null</span>)</div><div class="line">             <span class="keyword">return</span>;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="keyword">while</span> (nextSegmentIndex &gt;= <span class="number">0</span>) &#123;</div><div class="line">         Segment&lt;K,V&gt; seg = segments[nextSegmentIndex--];</div><div class="line">         <span class="keyword">if</span> (seg.count != <span class="number">0</span>) &#123;</div><div class="line">             currentTable = seg.table;</div><div class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> j = currentTable.length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</div><div class="line">                 <span class="keyword">if</span> ( (nextEntry = currentTable[j]) != <span class="keyword">null</span>) &#123;</div><div class="line">                     nextTableIndex = j - <span class="number">1</span>;</div><div class="line">                     <span class="keyword">return</span>;</div><div class="line">                 &#125;</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>不想再多介绍了，唯一需要注意的是跳到下一个段时，一定要先读取下一个段的count变量。 </p>
<p>这种迭代方式的主要效果是不会抛出ConcurrentModificationException。一旦获取到下一个段的table，也就意味着这个段的头结点在迭代过程中就确定了，在迭代过程中就不能反映对这个段节点并发的删除和添加，对于节点的更新是能够反映的，因为节点的值是一个volatile变量。</p>
<blockquote>
<p><strong>Note:</strong></p>
<ul>
<li>写volatile变量和它之前的读写操作是不能reorder(重排序)的，读volatile变量和它之后的读写操作也是不能reorder的。</li>
<li>注意对count变量和modCount变量的读取写入，在写count前一定有写modCount，读modCount前先读count。</li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ConcurrentHashMap是Java 5中支持高并发、高吞吐量的线程安全HashMap实现&lt;/p&gt;
&lt;h3 id=&quot;锁分离-Lock-Stripping&quot;&gt;&lt;a href=&quot;#锁分离-Lock-Stripping&quot; class=&quot;headerlink&quot; title=
    
    </summary>
    
      <category term="java" scheme="https://swinepig.github.io/categories/java/"/>
    
    
      <category term="技术" scheme="https://swinepig.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="java" scheme="https://swinepig.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>两个简单递归程序</title>
    <link href="https://swinepig.github.io/2015/07/22/recursion/"/>
    <id>https://swinepig.github.io/2015/07/22/recursion/</id>
    <published>2015-07-22T13:02:33.000Z</published>
    <updated>2016-09-03T13:19:16.430Z</updated>
    
    <content type="html"><![CDATA[<p>两个简单递归程序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</div><div class="line">  </div><div class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> is_turn;</div><div class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] array;</div><div class="line">  </div><div class="line"> <span class="comment">/**</span></div><div class="line">  * 逆时针数字排序</div><div class="line">  * <span class="doctag">@param</span> args</div><div class="line">  */</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">     Scanner sc = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">     <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">         System.out.println(<span class="string">"请输入行数和列数  已空格分开"</span>);</div><div class="line">         String str = sc.next();</div><div class="line">         <span class="keyword">if</span> (<span class="string">"exit"</span>.equalsIgnoreCase(str)) &#123;</div><div class="line">             System.exit(<span class="number">0</span>);</div><div class="line">         &#125;</div><div class="line">         generate(Integer.parseInt(str.split(<span class="string">","</span>)[<span class="number">0</span>]), Integer.parseInt(str</div><div class="line">                 .split(<span class="string">","</span>)[<span class="number">1</span>]));</div><div class="line">     &#125;</div><div class="line">  </div><div class="line"> &#125;</div><div class="line">  </div><div class="line"> <span class="comment">/***</span></div><div class="line">  * </div><div class="line">  * <span class="doctag">@param</span> row</div><div class="line">  * <span class="doctag">@param</span> coloum</div><div class="line">  */</div><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generate</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> coloum)</span> </span>&#123;</div><div class="line">     array = <span class="keyword">new</span> <span class="keyword">int</span>[row][coloum];</div><div class="line">     disPlayArray(generateCircle(<span class="number">1</span>, row, coloum, <span class="number">1</span>));</div><div class="line"> &#125;</div><div class="line">  </div><div class="line"> <span class="comment">/***</span></div><div class="line">  * </div><div class="line">  * <span class="doctag">@param</span> startNum</div><div class="line">  * <span class="doctag">@param</span> row</div><div class="line">  * <span class="doctag">@param</span> coloum</div><div class="line">  * <span class="doctag">@return</span></div><div class="line">  */</div><div class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] generateCircle(<span class="keyword">int</span> startNum, <span class="keyword">int</span> row, <span class="keyword">int</span> coloum,</div><div class="line">         <span class="keyword">int</span> cengshu) &#123;</div><div class="line">     <span class="keyword">if</span> (row == <span class="number">0</span> || coloum == <span class="number">0</span>) &#123;</div><div class="line">         <span class="keyword">return</span> array;</div><div class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (row == <span class="number">1</span> &amp;&amp; coloum == <span class="number">1</span>) &#123;</div><div class="line">         array[cengshu - <span class="number">1</span>][cengshu - <span class="number">1</span>] = startNum;</div><div class="line">         <span class="keyword">return</span> array;</div><div class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (row == <span class="number">1</span> &amp;&amp; coloum != <span class="number">1</span>) &#123;</div><div class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = cengshu - <span class="number">1</span>; i &lt;= coloum+cengshu-<span class="number">2</span>; i++) &#123;</div><div class="line">             array[cengshu - <span class="number">1</span>][i] = startNum++;</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">return</span> array;</div><div class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (row != <span class="number">1</span> &amp;&amp; coloum == <span class="number">1</span>) &#123;</div><div class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = cengshu - <span class="number">1</span>; i &lt;= row+cengshu-<span class="number">2</span>; i++) &#123;</div><div class="line">             array[i][cengshu - <span class="number">1</span>] = startNum++;</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">return</span> array;</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">         is_turn = <span class="keyword">false</span>;<span class="comment">// 初始化为false</span></div><div class="line">         <span class="keyword">int</span> endNum = <span class="number">2</span> * (row + coloum) + startNum - <span class="number">5</span>;</div><div class="line">         <span class="keyword">int</span> x = cengshu - <span class="number">1</span>, y = cengshu - <span class="number">1</span>;</div><div class="line">  </div><div class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = startNum - <span class="number">1</span>; i &lt; endNum; i++) &#123;</div><div class="line">             array[x][y] = i + <span class="number">1</span>;</div><div class="line">             <span class="keyword">if</span> ((x + <span class="number">1</span>) &lt; row + cengshu - <span class="number">1</span> &amp;&amp; !is_turn) &#123;</div><div class="line">                 x++;</div><div class="line">             &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((y + <span class="number">1</span>) &lt; coloum + cengshu - <span class="number">1</span> &amp;&amp; !is_turn) &#123;</div><div class="line">                 <span class="keyword">if</span> ((++y) == (coloum + cengshu - <span class="number">2</span>)) &#123;</div><div class="line">                     is_turn = <span class="keyword">true</span>;</div><div class="line">                 &#125;</div><div class="line">             &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((y + <span class="number">1</span>) == coloum + cengshu - <span class="number">1</span> &amp;&amp; x &gt; cengshu - <span class="number">1</span></div><div class="line">                     &amp;&amp; is_turn) &#123;</div><div class="line">                 x--;</div><div class="line">             &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((x + <span class="number">1</span>) == cengshu &amp;&amp; y &gt; cengshu &amp;&amp; is_turn) &#123;</div><div class="line">                 y--;</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">return</span> generateCircle(endNum + <span class="number">1</span>, row - <span class="number">2</span>, coloum - <span class="number">2</span>, cengshu + <span class="number">1</span>);</div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line">  </div><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">disPlayArray</span><span class="params">(<span class="keyword">int</span>[][] array)</span> </span>&#123;</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</div><div class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array[i].length; j++) &#123;</div><div class="line">             <span class="keyword">if</span> (array[i][j] &gt; <span class="number">9</span> &amp;&amp; array[i][j] &lt; <span class="number">100</span>) &#123;</div><div class="line">                 System.out.print(array[i][j] + <span class="string">"  "</span>);</div><div class="line">             &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[i][j] &lt; <span class="number">10</span>) &#123;</div><div class="line">                 System.out.print(array[i][j] + <span class="string">"   "</span>);</div><div class="line">             &#125; <span class="keyword">else</span> &#123;</div><div class="line">                 System.out.print(array[i][j] + <span class="string">" "</span>);</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line">         System.out.println();</div><div class="line">     &#125;</div><div class="line">  </div><div class="line"> &#125;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.Scanner;</div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</div><div class="line">   </div><div class="line"> <span class="comment">/*</span></div><div class="line">  * 输入字符串长度，字符串比如“3，1，2，4”,m值</div><div class="line">  * 所输入的字符串数字都是大于0</div><div class="line">  * 要求从左往右循环计数，数到m就将第m个元素出列，然后将出列的元素值赋给m</div><div class="line">  * 如此进行直到所有元素都出列</div><div class="line">  * */</div><div class="line">  </div><div class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ZERO = <span class="number">0</span>;</div><div class="line">  </div><div class="line"> <span class="comment">/**</span></div><div class="line">  * <span class="doctag">@param</span> args</div><div class="line">  */</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">  </div><div class="line">     System.out.println(<span class="string">"请输入字符串长度"</span>);</div><div class="line">     Scanner sc1 = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">     Integer.parseInt(sc1.next());</div><div class="line">  </div><div class="line">     System.out.println(<span class="string">"请输入字符串 比如\"3,1,2,4\""</span>);</div><div class="line">     Scanner sc2 = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">     String str = sc2.next();</div><div class="line">     <span class="comment">// 将字符串装入list中</span></div><div class="line">     List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.split(<span class="string">","</span>).length; i++) &#123;</div><div class="line">         list.add(Integer.parseInt(str.split(<span class="string">","</span>)[i]));</div><div class="line">     &#125;</div><div class="line">  </div><div class="line">     System.out.println(<span class="string">"请输入M值"</span>);</div><div class="line">     Scanner sc3 = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">     <span class="keyword">int</span> mValue = Integer.parseInt(sc3.next());</div><div class="line">  </div><div class="line">     <span class="comment">// System.out.println(strLength + str + mValue);</span></div><div class="line">  </div><div class="line">     process(list, mValue);</div><div class="line"> &#125;</div><div class="line">  </div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;Integer&gt; list, <span class="keyword">int</span> mValue)</span> </span>&#123;</div><div class="line">  </div><div class="line">     <span class="keyword">int</span> list_size = list.size();<span class="comment">// 列表长度</span></div><div class="line">     <span class="keyword">if</span> (list_size &gt; <span class="number">1</span>) &#123;</div><div class="line">         <span class="comment">// mValue与列表长度求模,从list表中取出的元素</span></div><div class="line">         <span class="keyword">int</span> index = mValue % list_size;<span class="comment">// list表中第index个元素</span></div><div class="line">         <span class="keyword">int</span> ys = <span class="number">0</span>;</div><div class="line">  </div><div class="line">         <span class="keyword">int</span> offset = <span class="number">0</span>;<span class="comment">// index和列表长度之差</span></div><div class="line">         <span class="keyword">int</span> new_mValue = <span class="number">0</span>;</div><div class="line">         <span class="keyword">if</span> (ZERO != index) &#123;</div><div class="line">             <span class="comment">// ys=list.get(index);</span></div><div class="line">             ys = list.remove(index - <span class="number">1</span>);</div><div class="line">             System.out.print(ys+<span class="string">" "</span>);</div><div class="line">             offset = list_size - index;</div><div class="line">             new_mValue = ys - offset;</div><div class="line">             <span class="keyword">if</span> (new_mValue &lt;= <span class="number">0</span>) &#123;</div><div class="line">                 new_mValue = index -<span class="number">1</span>+ ys;</div><div class="line">             &#125;</div><div class="line">         &#125; <span class="keyword">else</span> &#123;</div><div class="line">             <span class="comment">// ys=list.get(list_size);</span></div><div class="line">             ys = list.remove(list_size - <span class="number">1</span>);</div><div class="line">             System.out.print(ys+<span class="string">" "</span>);</div><div class="line">             new_mValue = ys;</div><div class="line">         &#125;</div><div class="line">  </div><div class="line">         <span class="comment">// 递归</span></div><div class="line">         process(list, new_mValue);</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">         System.out.print(list.get(list_size - <span class="number">1</span>)+<span class="string">" "</span>);</div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;两个简单递归程序&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div cla
    
    </summary>
    
      <category term="java" scheme="https://swinepig.github.io/categories/java/"/>
    
    
      <category term="技术" scheme="https://swinepig.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="java" scheme="https://swinepig.github.io/tags/java/"/>
    
  </entry>
  
</feed>
